# 6-7일차 (21.01.30 일)
3장. 함수

## 내용
- 어떤 프로그램이든 가장 기본적인 단위가 함수다.
- 함수를 만드는 첫째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다.
- Sparkle은 모든 함수가 2줄, 3줄, 4줄 정도였다. 각 함수가 너무도 명백했다. 각 함수가 이야기 하나를 표현했다. 각 함수가 너무도 멋지게 다음 무대를 준비했다. 바로 이것이 답이다!
- if 문/else 문/while 문 등에 들어가는 블록은 한 줄이어야 한다. 대게 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
- 중첩 구조가 생길만큼 함수가 커져서는 안 된다. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다.
- 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서가 아니던가.
- 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.
- 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
- 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다. 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.
- 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
- 핵심은 짧으면서도 '한 가지'만 하는 함수다.
- 각 함수는 다음 함수를 소개한다. 또한 각 함수는 일정한 추상화 수준을 유지한다.
- switch 문은 작게 만들기 어렵다. 또한 '한 가지' 작업만 하는 switch 문도 만들기 어렵다. 본질적으로 switch 문은 N가지를 처리한다.
- 나는 switch 문을 단 한 번만 참아준다. 다형적 객체를 생성하는 코드 안에서다. 이렇게 상속 관계로 숨긴 후엔ㄴ 절대로 다른 코드에 노출하지 않는다.
- 서술적인 이름을 사용하라!
- 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
- 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 이름을 정하느라 시간을 들여도 괜찮다.
- 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드르 개선하기 쉬워진다. 좋은 이름을 고른 후 코드를 더 좋게 재구성하는 사례도 없지 않다.
- 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
- 함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개고, 다음은 2개다. 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안 된다.
- 테스트 관점에서 보면 인수는 더 어렵다. 인수가 3개를 넘어가면 인수마다 유효한 값으로 모든 조합을 구성해 테스트하기가 상당히 부담스러워진다.
- 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다. 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까! 플래그가 참이면 이걸 하고 거짓이면 저걸 한다는 말이니까!
- 이항 함수가 무조건 나쁘다는 소리는 아니다. 하지만 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다.
- 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
- 가변 함수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다.
- 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
- 함수 이름에 키워드를 추가하는 형식이 있다.
  ```java
  assertEquals(expected, actual) -> assertExpectedEqualsActual(expected, actual)
  ```
- 부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하니까.
- 만약 시간적인 결합이 필요하다면 함수 이름에 분명히 명시한다.
- 함수 선언부를 찾아보는 행위는 코드를 보다가 주춤하는 행위와 동급이다. 인지적으로 거슬린다는 뜻이므로 피해야 한다.
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다.
- 오류 코드보다 예외를 사용하라! 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다.
- try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다.
- 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생된다. 따라서 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다.
- 반복하지 마라! 중복을 없앴더니 모듈 가독성이 크게 높아졌다는 사실을 깨달으리라.
- 중복은 소프트웨어에서 모든 악의 근원이다. 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.
- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 처음에는 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수 목록도 아주 길다. 이름은 즉흥적이고 코드를 중복된다. 하지만 나는 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스도 만든다.
- 그런 다음 나는 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다. 이 와중에도 코드는 항상 단위 테스트를 통과한다.
- 최종적으로는 이 장에서 설명한 규칙을 따르는 함수가 얻어진다. 처음부터 탁 짜내지 않는다. 그게 가능한 사람을 없으리라.
- 프로그래밍의 기술은 언제나 언어 설계의 기술이다.
- 여러분이 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아떨어져야 이야기를 풀어나가기가 쉬워진다는 사실을 기억하기 바란다.

## 감상
- 하나의 함수에서 한 가지 일만 해야한다는 말을 많이 들었고 코드 리뷰에서도 그런 리뷰를 종종 받았었다. 근데 읽다보니 지키지 못하고 있었던 게 많다는 생각이 들었다. 
- 오류 처리를 할 때 오류 동작을 구분하고, 인수는 적게 설정하고, if문 등의 중첩 구조를 줄이는 것들을 지키지 못한 코드가 많이 생각났다.
- 이전 장에서도 이름짓기의 중요성을 강조했었는데, 함수 이름을 짓는 것도 중요하다고 한다. 함수에 인수가 들어가는 경우에는 선언부를 찾아보지 않고도 인수와 함수의 의미를 알기 쉽도록 이름을 지어야 한다고 한다. 인수가 들어가는 경우나 그렇지 않은 경우라도 의미를 알기 쉽지 않아 선언부를 찾아본 일이 적지 않은데 그 문제를 단순히 이름을 명확히 짓는 것으로 해결할 수 있다는 것에 새로웠다.
- 최근 같은 내용을 구현한 여러 사람들의 코드를 읽을 일이 있었다. 함수를 최대한 작게 쪼갠 함수는 이야기처럼 술술 읽기 쉬웠고, 함수를 분리하지 않고 한 곳에 몰아넣은 코드는 이해하는데 오래 걸렸다.
- 헤밍웨이가 초고는 쓰레기라고 했다. 글쓴이도 코드를 여러번 수정함으로써 이 장의 규칙을 따르는 코드를 얻을 수 있다고 했다. 다른 사람들의 코드를 볼 때 여러번 수정한 코드와 한 번만에 짜낸 코드는 차이가 보였다. 코드를 여러번 수정할수록 이 책에서 말하는 클린 코드를 작성할 수 있겠다는 생각이 들었다. 글쓴이 같은 사람들은 한 번만에 깔끔한 코드를 작성할 수 있지 않을까 했는데 그게 가능한 사람은 없을 것이라고 한다.
