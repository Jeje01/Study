- JS 이슈는 리액트 개발 도구에서 확인할 수 없어 범용적인 브라우저 개발자 도구를 활용해야 함

# 7.1 크롬 개발자 도구란?

- `크롬 개발자 도구`
    - 웹페이지에서 일어나는 거의 모든 일을 확인할 수 있는 강력한 개발 도구
    - 크롭 개발자 도구에서 웹사이트를 제대로 디버깅하고 싶다면 시크릿 모드에서 페이지와 개발자 도구 여는 것을 권장
        - 브라우저에 설치돼 있는 각종 확장 프로그램 때문 : 웹페이지 방문 시 확장 프로그램 실행 위해 전역 변수나 HTML 요소에 실제 웹 앱이 제공하지 않은 다른 정보를 추가할 수 있음

# 7.2 요소 탭

![image](https://github.com/user-attachments/assets/e57967a9-0d07-4d9c-abea-a48b1e1df548)

- 왼쪽에는 HTML 트리가 표시됨
- 오른쪽에는 왼쪽에서 선택한 요소와 관련 각종 정보가 표시됨

## 7.2.1 요소 화면

- `왼쪽 화면`
    - 현재 웹페이지를 구성하는 HTML을 나타냄
    - 원하는 태그 클릭 시 브라우저 페이지의 해당 요소가 강조되며, 해당 태그와 관련된 정보 확인 가능
- 웹페이지의 DOM을 직접적으로 수정
    - 프로덕션으로 개발된 페이지에서 수정된 내용이 어떻게 보이는지 미리 확인할 수 있어 편리함
    - 개발 모드에서 리액트 코드를 수정해 핫 리로딩을 거치지 않아도 확인하 수 있어 빠른 작업이 가능함
- 요소의 중단점 사용해 디버깅

    ![image](https://github.com/user-attachments/assets/46d5ae81-bdbb-418c-8af6-98b5de18ce90)

    - 배너 등 코드에 의해 클래스나 속성값이 동적으로 제어되는 DOM 디버깅 가능
    - 디버깅하고 싶은 요소를 선택 후 마우스 오른쪽 버튼 클릭 후 중단점 위치 선택 후 중단 원하는 옵션을 클릭하기
    - 중단 위치 설정 시 중단 관련 작업 발생 시마다 브라우저가 렌더링을 중단하고 해당 요소 변경을 일으킨 소스코드를 보여줌
    - 중단점으로 해당 노드의 class명을 수정하려는 작업이 리액트에서 일어났다는 사실을 알 수 있음
    - 요소에 속성을 추가, 수정, 삭제하거나 해당 요소를 스크린샷으로 캡처하거나 숨기는 등 HTML DOM 관련 다양한 작업 수행 가능

## 7.2.2 요소 정보

- 요소 탭 오른쪽 : 해당 요소 관련 정보를 얻을 수 있음

    ![image](https://github.com/user-attachments/assets/c67fe0c8-c6e3-4236-ab05-faabe2e93581)

    - `스타일` : 스타일이 선언돼 있는 파일 확인 가능, 변경 결과 미리 확인 가능
    - `계산됨` : 적용된 스타일이 결과적으로 어떤 결과물로 나타나는지 확인 가능
    - `레이아웃` : CSS 그리드나 레이아웃 관련 정보 알 수 있음
    - `이벤트 리스너`
        - 현재 요소에 부착된 각종 이벤트 리스너 확인 가능
        - 상위 버튼 체크 해제 시 딱 해당 요소에 명확히 부착된 이벤트만 볼 수 있음
        - 이벤트 버블링 등으로 이벤트 발생시키는 경우에는 확인 불가
    - `DOM 중단점` : 중단점이 있는지 알려줌
    - `속성` : 해당 요소가 가지는 모든 속성값 나타냄
    - `접근성` : 웹 이용에 어려움을 겪는 사람들을 위한 스크린리더기 등이 활용하는 값
- DOM에 추가된 이벤트 리스너, 접근성 등 DOM 관련 모든 정보 확인 가능

# 7.3 소스 탭

![image](https://github.com/user-attachments/assets/ee5b4ce3-d94a-423b-be7a-b674ef169d87)

- 웹 앱을 불러오기 위해 실행하거나 참조된 모든 파일 확인 가능 (JS, CSS, HTML, 폰트 등)
- 파일을 열어야 디버깅할 파일 확인 가능
- 프로덕션 모드 : 파일이 모두 압축돼있어 디버깅하기 매우 불편하지만 개발 모드에서 유용하게 사용 가능
    - CRA로 생성한 프로젝트를 개발 모드에서 실행 후 파일을 열면 생성된 파일 확인 가능
- 중단점 생성해 JS 실행을 중단시키고 디버깅 수행 가능
    - 코드에 debugger를 선언하는 것과 동일한 역할을 함
    - 소스코드를 오염시키지 않아 더 유용함
- ex. useEffect 내부에 중단점 생성
    - 중단점 만들어 다음 코드 시작 중지 가능
    - 이전에 할당한 변수에 어떤 값이 들어있는지 확인 가능
    - 본인이 작성하지 않은 리액트 파일 내에서 중단점 생성해 해당 소스 파일을 찾아 중단점 걸어볼 수 있음
- 오른쪽 정보
    - `감시`
        - 감시하고 싶은 변수 선언해 해당 변수의 정보를 확인할 수 있는 메뉴
        - 왼쪽에서 제공하는 변수 외에 디버깅 시점에서 특정 변수의 값을 알고 싶을 때 사용
    - `중단점` : 현재 웹사이트에서 추가한 중단점 확인
    - `범위`
        - 현재 중단점에서의 스코프를 의미
        - 로컬은 현재 로컬 스코프를 의미, 이 스코프에서 접근 가능한 값 확인
        - 클로저, 전역 스코프 등도 확인 가능
    - `콜 스택`
        - 현재 중단점의 콜스택 확인
        - JS 코드가 실행되며 생성되는 실행 콘텍스트가 어떻게 저장돼 현재 어떤 모습을 하고 있는지 직접 확인 가능
    - `전역 리스너` : 전역 스코프에 추가된 리스너 목록 확인 가능
    - `XHR/Fetch, DOM, 이벤트 리스너, CSP 위반 중단점` : 소스 중단점 이외에 다양한 중단점 확인 가능
- 변수의 값을 미리 보여주는 기능, 감시에 변수를 추가해 실제 변숫값을 확인하는 기능 사용 시 번거롭게 console.log로 디버깅하지 않아도 됨
- JS 파일에서 확인할 수 없는 스코프, 호출 스택 등 현재 JS가 실행되고 있는 구조도 확인 가능

# 7.4 네트워크 탭

- 해당 웹페이지 접속부터 발생하는 모든 네트워크 관련 작동이 기록됨
- HTTP 요청부터 웹 소켓까지 웹페이지가 외부 데이터와 통신하는 정보 확인 가능

![image](https://github.com/user-attachments/assets/42f88757-0e6a-4aa1-ac49-f02f142a0888)

- `왼쪽`
    - 실제 해당 페이지 불러올 때 발생한 네트워크 요청 확인 가능
    - 페이지 로딩 과정을 대략적으로 확인 가능
- 웹페이지는 최초에 HTML을 다운로드하고, HTML을 파싱하는 과정에서 만난 JS를 다운도르함
    - 개발자 모드 : 웹 소켓 통해 핫 리로딩되는 것을 확인 가능
- ex. 요청이 두 번 실행되는 경우
    - useEffect 오사용으로 발생하는 문제일 수 있어 리액트 코드에 문제 있는지 확인 가능
- `하단`
    - 페이지 불러오는 기간 동안 발생한 총 요청 건수와 총 다운로드한 업로드 리소스의 크기 확인 가능
- 가급적 네트워크 리소스 요청 횟수와 크기를 줄일 필요가 있음
    - 생각 이상으로 리소스 크기가 크다면 리소스를 압축하거나 이미지는 최적화할 필요 있음
- 스크린샷 캡쳐 기능 : 네트워크 요청 흐름에 따라 웹페이지가 어떻게 로딩되고 있는지 확인 가능
- 코드 내부에서 발생하는 fetch 요청 외에도 외부 CDN에서 가져오는 이미지 리소스 요청 등도 확인 가능
    - 다음을 확인 가능
        - 사용자에게 먼저 노출되거나, 노출되는 영역이 큰 중요한 콘텐츠가 우선적으로 다운로드되는지
        - 우선순위 낮은 이미지가 나중에 다운로드되는지
- 페이지가 자연스럽게 완성되는 모습이 중요해 스크린샷 캡처를 통해 의도대로 완성되어가는지 확인
- 네트워크 탭에서 확인해 봐야 하는 점
    - 불필요한 요청 또는 중복되는 요청이 없는지
    - 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
    - 리소스를 불러오는 속도는 적절한지 또는 너무 속도가 오래 걸리는 리소스는 없는지
    - 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지

# 7.5 메모리 탭

- 현재 웹페이지가 차지하는 메모리 관련 정보 확인
- 가장 난이도 높고 까다로운 도구
- 앱에 발생하는 메모리 누수, 속도 저하, 웹페이지 프리징 현상 확인 가능
- 프로파일링 작업을 거쳐야 함
- 프로파링일 유형 세 가지
    - `힙 스냅샷` : 현재 메모리 상황을 사진 찍듯히 촬영 가능
    - `타임라인의 할당 계측` : 시간의 흐름에 따라 메모리 변화 확인 가능. 로딩되는 과정의 메모리 변화 또는 페이지에서 어떠한 상호작용을 했을 때 메모리의 변화 과정 알고 싶을 때 사용
    - `할당 샘플링` : 메모리 공간 차지하는 JS 함수 확인 가능

## 7.5.1 자바스크립트 인스턴스 VM 선택

- JS VM 인스턴스 선택 항목에서 현재 실행 중인 JS VM 인스턴스 확인 가능
- 디버깅하고 싶은 JS VM 환경 선택
- 환경별 힙 크기를 볼 수 있는데, 실제 해당 페이지가 JS 힙을 얼마나 점유하는지 나타냄
- 이 크기는 JS 실행에 따라 실시간으로 바뀌며 이 크기만큼 사용자의 브라우저에 부담을 줌

## 7.5.2 힙 스냅샷

- 테스트
    1. 페이지 진입 후 페이지 로딩 완료 시 힙 스냅샷 촬영을 한 번 수행
    2. 테스트용 코드 수행 후 힙 스냅샷 재촬영
    3. 왼쪽 힙 스냅샷 화면에서 크기 증가한 것 확인 가능
    4. 메모리 크기 차이 원인 정확히 파악 위해 두 개 스냅샷 사이에 할당된 객체 클릭해 얕은 크기 항목 기준으로 내림차순 정렬
    - 어떤 변수가 메모리 크게 잡아먹는지 확인 가능
        - 두 스냅샷 사이에 일어난 유저 인터랙션으로 메모리 사용량 차이가 발생한 것과 메모리를 크게 차지하는 것이 객체라는 점을을 확인 가능
    - 해당 객체 대상을 전역 변수로 저장 가능
- 얕은 크기
    - 객체 자체가 보유하는 메모리 바이트의 크기를 나타냄
    - `유지된 크기` : 해당 객체 자체뿐만 아니라 다른 부모가 존재하지 않는 모든 자식 객체들의 크기까지 더한 값
    - 메모리 누수 찾을 때는 얕은 크기는 작으나 유지된 크기가 큰 객체를 찾아야 함
        - 두 크기 차이가 큰 객체는 다수의 다른 객체를 참조하는 것이며, 해당 객체가 복잡한 참조 관계를 가진다는 뜻
        - 이런 객체가 오랜 시간 메모리에 남아있다면 그로 인해 많은 메모리 점유하고 있을 수 있음
        - 메모리 누수가 의심스럽다면 이러한 두 크기의 차이가 큰 객체를 최우선으로 찾아야 함
- 스냅샷 촬영 활용은 두 개 이상을 촬영한 후 그 차이만 비교하는 것이 훨씬 수월함
    - useMemo, useCallback과 같은 의존성이 있는 값들이 정말로 렌더링 사이에 그대로 유지되는지도 확인 가능
        - useCallback으로 감싸면 재생성되지 않기 때문에 스냅샷 사이에 할당된 객체에서 확인 불가
        - 익명 화살표 함수는 사용은 용이하지만 디버깅에는 도움이 되지 않음
            
            ⇒ 빠르고 원활한 디버깅을 위해서는 기명 함수를 사용하는 편이 좋음
            
- 힙 스냅샷을 통해 메모리 누수 정보를 확인하려면 메모리 누수가 발생하는 것으로 예상되거나 혹은 위험이 존재할 것 같은 스크립트 전후로 촬영해 비교하는 것이 좋음

## 7.5.3 타임라인 할당 계측

- 시간의 흐름에 따라 메모리 변화를 확인할 수 있는 기능
- 시간의 흐름에 따라 메모리의 변화를 모두 기록하기 때문에 상대적으로 많은 부담이 발생함
- ex. 버튼 클릭 시 마다 몇 천개씩 배열에 새로운 아이템이 생기는 경우
    - 리액트는 이 배열을 모두 DOM에 그려야 함
    - DOM을 그리기 위해 리액트가 1:1 구조로 생성하는 FiberNode와 해당 배열을 담아야 하는 array가 엄청나게 커짐
- 장점 : 기간을 좁혀서 확인 가능함
- 시간의 흐름에 따른 메모리 점유율을 자세히 알고 싶을 때 사용
- 앱의 메모리 사용 현황을 자세히 파악할 수 있음

## 7.5.4 할당 샘플링

- 할당 계측과 비슷하지만 JS 실행 스택별로 분석 가능, 이 분석을 함수단위로 함
- ex. 버튼 클릭 시마다 더미데이터를 추가함
    - 할당 샘플링 하고 싶은 VM을 선택 후 시작 클릭
    - 할당 샘플링 무거운 순으로 정렬 시 가장 많은 바이트 차지 함수 확인 가능
    - 함수가 어느 파일에서 어떻게 정의됐는지도 확인 가능
- 프로파일링 시 브라우저에 주는 부담을 최소화할 수 있어 장시간에 걸쳐 디버깅 수행할 때 유리함
- 메모리 누수가 짐작되지만 정확히 어디에서 발생하는지 확인이 어려워 스냅샷 비교가 어려울 경우, 오랜 기간 메모리 누수가 의심돼 프로파일링을 자기간 수행해야 하는 경우에 사용하기 좋음

# 7.6 Next.js 환경 디버깅하기

- SSR 수행 JS 환경에서 메모리 누수가 발생하면 서버 자체에 부담이 발생하고, 서버의 부담은 곧 모든 사용자가 서비스 사용이 불가한 상황을 초래함
- 서버 환경도 동일하게 크롬 개발자 도구로 디버깅이 가능함

## 7.6.1 Next.js 프로젝트를 디버그 모드로 실행하기

```json
"dev": NODE_OPTIONS='--inspect' next dev
```

- next dev 실행 시 디버거가 활성화되며 디버그 모드가 켜진 것을 확인 가능
- 웹소켓 주소가 나타나면 디버거에 연결된 준비가 된 것
- chrome://inspect로 이동
- `Open dedicated DevTools for Node` 클릭 시 새로운 창에서 개발자 도구가 나타남

## 7.6.2 Next.js 서버에 트래픽 유입시키기

- SSR과 같이 서버에서 제공되는 서비스는 서버를 실행한 뒤 사용자가 서서히 유입되며 메모리 누수가 발생하는 경우가 많음
- 서버에 직접 트래픽을 발생시켜서 확인하는 게 가장 확실한 방법
- 오픈소스 도구인 ab를 활용
    - ab : 아파치 재단에서 제공하는 웹서버 성능 검사 도구로 HTTP 서버의 성능을 벤치마킹할 수 있음
        
        ```json
        ab -k -c 50 -n 10000 "http://127.0.0.1:3000/"
        ```
        
    - 한번에 50개의 요청을 총 10,000회 시도함
    - IP나 올바른 주소를 기재해야함
    - 요청 수행 및 응답에 걸린 시간, 바이트 크기 등을 확인 가능

## 7.6.3 Next.js의 메모리 누수 지점 확인하기

- ex. getServerSideProps가 있는 Next.js 페이지에서 getServerSideProps가 실행될 때마다 전역 변수로 선언된 배열에 계속 push하는 경우
    - 해당 페이지에 사용자가 방문할 때마다 메모리 사용이 점차 늘어날 것
    - 메모리 도구로 프로파일링한 결과, getServerSideProps의 다수 실행과 메모리 누수 확인 가능
    - getServerSideProps는 페이지 접근 요청이 있을 때마다 실행되므로 최대한 부수 효과가 없는 순수 함수로 만들어야 함
    - 이 함수 내부에서 외부 스코프의 변수에 의존하는 작업을 한다면 지금과 같은 메모리 누수 상황을 마주할 수도 있을 것
- 대부분 메모리 누수의 원인이 불명확함
- 원인이 본인의 코드 또는 npm 라이브러리일 수도 있음

# 7.7 정리

- 여기까지의 내용으로 웹사이트 디버깅에 큰 문제가 없을 것
- 크롭 개발자 도구에는 웹페이지에서 일어나는 모든 정보가 담겨져 있음
