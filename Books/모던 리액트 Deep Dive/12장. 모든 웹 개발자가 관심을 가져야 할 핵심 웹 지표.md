# 12.1 웹사이트와 성능

- 사용자가 기대하는 사항
    1. 웹사이트를 방문한 목적을 손쉽게 달성
    2. 1번을 달성하는 데 걸리는 시간이 짧아야 함
    3. 개인정보 누출 등의 사고 없이 보안이 철저해야 함
- 리액트가 아무리 좋은 프레임워크라도 성능이 뒤떨어지면 이용자들의 호응을 얻기 어려움
- 웹사이트의 성능이 미치는 영향
    - 더 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다.
- 구글의 웹사이트 성능에 관한 통계
    - 전체 웹페이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만
    - 평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸림
- 개발자들이 성능 개선에 관심이 적은 이유
    - 성능을 개선하는 작업은 새로운 기능을 개발하는 것보다 쉽지도, 재밌지도 않고, 눈에 띄는 성능 향상을 기대하기도 어려움
    - 실무에 있는 개발자들은 항상 많은 양의 업무 요청을 처리하고 버그와 씨름하기 때문에 대부분 서비스 출시를 최우선 과제로 삼고 있음

# 12.2 핵심 웹 지표란?

- 구글의 핵심 웹 지표
    - LCP (Largest Contentful Paint)
    - FID (First Input Delay)
    - CLS (Cumulative Layout Shift)
- 핵심은 아니지만 특정 문제를 진단하는 데 사용 가능
    - TTFB : Time to First Byte
    - FCP : First Contentful Paint

# 12.3 최대 콘텐츠풀 페인트(LCP)

## 12.3.1 정의

- 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
- 크기가 크다고 하더라도 뷰포트 영역 밖에 넘치는 요소가 있다면 해당 영역의 크기는 고려되지 않음

## 12.3.2 의미

- 단순히 사용자에게 있어 로딩이란 일단 뷰포트 영역에 보이는 부분을 기준으로 함
- 사용자에게 페이지의 정보를 화면에 전달하는 속도를 객관적으로 한단하기 위한 지표

## 12.3.4 기준 점수

- 좋음 : 2.5초 이내
- 보통 : 4초 이내
- 나쁨 : 그 이상

## 12.3.5 개선 방안

### 텍스트는 언제나 옳다

- 가장 확실한 방법 : LCP 예상 영역에 이미지가 아닌 문자열을 넣는 것
- 이미지보다 텍스트 노출이 훨씬 빠름

### 이미지는 어떻게 불러올 것인가?

- <img> : 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견돼 빠르게 요청이 일어남
- <svg> 내부의 <img> : 모든 리소스를 다 불러온 이후에 이미지를 불러옴
- background-image : url() : background-image를 비롯해서 CSS에 있는 리소스는 항상 느림. 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문임. 가능하다면 background-image는 LCP와 같이 중요한 리소스에는사용하지 않는 것이 좋음

### 그 밖에 조심해야 할 사항

- 이미지 무손실 압출 : 최소한의 용량으로 서비스하는 것이 좋음
- loading=lazy 주의: 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략이지만 LCP의 이미지는 중요하지 않는 리소스로 분류해서는 안 됨
- fadein과 같은 각종 애니메이션 : LCP도 그만큼 늦어짐
- 클라이언트에서 빌드하지 말 것 : useEffect 코드가 있다면 HTML 다운로드 직후가 아닌 리액트 코드를 파싱하고 읽어서 API 요청을 보내고, 응답을 받는 만큼 늦어지게 됨. 가능한 한 서버에서 미리 빌드된 채로 오는 것이 좋음
- 최대 콘텐츠풀 리소스는 직접 호스팅: 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋음

# 12.4 최초 입력 지연(FID)

## 12.4.1 정의

- 웹사이트의 반응성을 측정하는 지표
- 정의
    
    ```markdown
    사용자가 페이지와 처음 상호 작용할 때(예: 링크를 클릭하거나 버튼을 탭하거나 사용자 지정 JavaScript 기반 컨트롤을 사용할 때)부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정함
    ```
    

## 12.4.2 의미

- 웹사이트 내부의 이벤트가 반응이 늦어지는 이유 : 대부분 해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문
- 메인 스데르가 바쁜 이유 : 대규모 렌더링이 일어나고 있거나, 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문
- 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있음
- 구글은 사용자 경험을 크게 4가지로 분류해 정의하는데 이를 RAIL이라고 함
    - Response: 50ms 미만으로 이벤트를 처리할 것
    - Animation: 애니메이션의 각 프레임의 10ms 이하로 생성할 것
    - Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
    - Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

## 12.4.3 예제

- 최초 입력 지연은 사용자가 E2E 도구 등이 직접 클릭 등의 입력을 발생시켜야 함
- 이벤트 핸들러가 완료되는 데 걸리는 시간은 측정하지 않음

## 12.4.4 기준 점수

- 좋음 : 100ms 이내
- 보통 : 300ms 이내
- 나쁨 : 그 이후

## 12.4.5 개선 방안

- 메인 스레드에 이벤트를 실행할 여유를 줘야 함

### 실행에 오래 걸리는 긴 작업을 분리

- 메인 스레드를 오래 점유해야 하는 긴 작업은 웹페이지 전반에 악영향을 미침
- 대안
    - 꼭 웹페이지에서 해야 하는 작업인가
        - 그렇지 않다면 서버로 옮겨서 처리하는 것이 좋음
    - 긴 작업을 여러 개로 분리하기
        - 꼭 웹페이지에서 처리해야 한다면 해당 작업을 여러 개로 분리하는 것이 좋음
        - 크롬의 경우 50ms 이상 걸리면 오래 걸리는 작업이라고 간주함
- 작업을 분리 : 웹페이지 최초 로딩에 필요하지 않은 내용을 나중에 불러오는 것도 포함됨
- 사용자의 액션으로 인해 노출되는 이러한 요소들은 리액트의 Suspense와 lazy를, 혹은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있음

### 자바스크립트 코드 최소화

- 번들러가 필요 없는 코드를 제거해 준다고 해도 필요 없는 코드가 존재할 수 있음
    
    ⇒ 지연 로딩 또는 우선순위 낮춰 불러오는 것이 좋음
    
- 폴리필 : 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드
    - 한 메서드에 들어가는 폴리필의 크기는 제법 큼
    - 폴리필 넣기 전에는 두 가지를 확인해봐야 함
        1. 폴리필이 필요한 환경인가?
            - 구형 브라우저 환경을 지원하지 않기로 결심했다면 필요가 없음
        2. 꼭 필요한 폴리필인가?
            - 사용하는 곳이 몇 군데 되지 않는다면 폴리필 사용보다 직접 저수준 자바스크립트 코드를 구현하는 편이 코드 크기를 줄이는 데 도움이 될 수 있음
    - Next.js의 SWC를 사용하고 있다면 이미 SWC 내부에 구현돼 있기 때문에 별도로 처리하지 않아도 될 것

### 타사 자바스크립트 코드 실행의 지연

- 타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 <script>의 async와 defer를 이용해 지연 불러오기를 하는 것이 좋음
    - `defer`
        - 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드
        - 다운로드 중에도 HTML 파싱 등의 메인 스레드 작업은 멈추지 않음
        - 이 스크립트의 실행은 페이지가 완전히 로딩된 이후에 맨 마지막에 실행됨
    - `async`
        - 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드
        - async 리소스의 다운로드가 완료되어 버리면 다른 리소스의 다운로드가 완료되는 것을 기다리지 않고 바로 실행함
        - async 리소스의 실행 순서는 다운로드가 완료된 순서대로 실행됨
    - `둘 다 없는 경우`
        - script를 만나는 순간 다운로드가 우선됨
        - 다운로드가 완료되면 코드 실행이 우선됨
        - 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄짐
    - 스크립트는 async, defer로 갈수록 실행은 뒤로 미뤄지지만 성능은 좋아짐. 타사 자바스크립트는 가능하면 async를, 더 가능하다면 defer로 지연하는 것이 좋음
    - 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 Intersection Observer를 이용해 뷰포트에 들어오는 시점에 불러오는 것이 좋음

# 12.5 누적 레이아웃 이동(CLS)

## 12.5.1 정의

- 로딩이 끝난 줄 알고 무언가를 클릭하려고 했는데 다른 요소가 로딩되면서 원래 클릭하려고 했던 요소를 클릭하지 못해 당황하기도 함
- CLS : 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것

## 12.5.2 의미

- 과거의 웹사이트는 제한적인 트래픽과 리소스로 인해 제공하는 정보가 굉장히 한정적임
- 최초 렌더링 이후에 실행되는 useEffect가 많을수록, 그리고 이 useEffect가 렌더링에 영향을 미칠수록 이 누적 레이아웃 이동에 좋지 못한 점수를 받을 가능성이 커짐
- 뷰포트 내부의 요소에 대해서만 측정

## 12.5.3 예제

- 로딩 상태임을 보여주는 스켈레톤 UI가 페이지 레이아웃을 고정시켜 CLS에 도움을 줌
- 미리 노출이 예상되는 부분을 HTML로 자리 잡아 두는 것이 CLS 지표에 큰 도움이 됨
- 사용자는 로딩이 어느 정도 있더라도 콘텐츠가 어떠한 방식으로 렌더링될지 안정적으로 예측할 수 있으며, 뷰포트 내부에서 큰 이동이나 불편을 겪지 않고도 원하는 콘텐츠를 볼 수 있음

## 12.5.4 기준 점수

- 좋음 : 0.1 이하
- 보통 : 0.25 이하
- 나쁨 : 그 외

## 12.5.5 개선 방안

### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

- 미리 무언가가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법
- 가장 좋은 방법은 SSR

### 폰트 로딩 최적화

- 폰트 또한 레이아웃 이동을 일으키는 원인 중 하나
- 폰트로 인해 발생할 수 있는 문제
    - `FOUT(flash of unstyled text)`
        - HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
    - `FOIT(flash of invisible text)`
        - HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상
- 유념해야할 점
    - <link>dml preload 사용
    - font-family: optionl
        - 폰트 불러올 수 있는 방법 5가지 : auto, block, swap, fallback, optional

### 적절한 이미지 크기 설정

- height: auto
    - 이미지의 높이를 명확하게 알지 못해 레이아웃 이동이 크게 발생함
- width, height 지정
    - 브라우저가 이미지 로딩 전에 적절한 가로세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둠
    - aspect-ratio 속성 덕분에, 브라우저의 user agent stylesheet에 포함돼 있으며, 이미지의 가로세로 비율을 자동으로 맞춰주는 역할을 함

## 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

### 최초 바이트까지의 시간(Time To First Byte, TTFB)

- 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표
- 개선 시 고려할 사항
    - SSR을 수행하고 있다면
        - 로직을 최적화해 페이지를 최대한 빨리 준비시켜야 함
    - 주 방문객의 국적을 파악해 최대한 해당 국적과 가깝게 서버를 위치시키는 것이 좋음

### 최초 콘텐츠풀 페인트(First Contentful Paint, FCP)

- 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정함
- 최초 콘텐츠풀 페인트 개선 시 고려 사항
    - TTFB 개선
    - 렌더링을 가로막는 리소스 최소화
    - Above the Fold에 대한 최적화
    - 페이지 리다이렉트 최소화
    - DOM 크기 최소화

# 12.6 정리

- 3가지 주요 지표와 추가 2가지 지표 정도만 살펴보면 좋은 사용자 경험 제공 가능
