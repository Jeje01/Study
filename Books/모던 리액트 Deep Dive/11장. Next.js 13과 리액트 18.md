- Next.js 13 : 릴리스 역사 중 가장 큰 변화가 있는 릴리스
    - react 19을 채택함
    - 레이아웃 지원을 본격적으로 지원함
    - 바벨을 대체할 swc를 뒤이어 웹팩을 대체할 Turbopack까지 출시함

# 11.1 app 디렉터리의 등장

- Next.js의 아쉬운 점으로 평가받던 것 : 레이아웃의 존재
- 13버전 이전 : 페이지 공통으로 무언가를 집어 넣을 수 있는 곳은 _document와 _app이 유일함
    - _document
        - <html>과 <body> 태그 수정, SSR 시 styled-components 등 일부 CSS-in-JS를 지원하기 위한 코드를 삽입
        - 서버에서만 작동해 클라이언트 로직 붙이는 것을 금지함
    - _app
        - 페이지 초기화를 위한 용도
        - 다음 작업이 가능함
            - 페이지 변경 시에 유지하고 싶은 레이아웃
            - 페이지 변경 시 상태 유지
            - componentDidCatch를 활용한 에러 핸들링
            - 페이지간 추가적인 데이터 삽입
            - global CSS 주입
- Next.js 12까지는 공통 레이아웃 유지 방법은 _app이 유일
    - 제한적이며 각 페이지별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족함

## 11.1.1 라우팅

- 기존에 /pages로 정의하던 라우팅 방식이 /app 디렉터리로 이동
- 파일명으로 라우팅하는 것이 불가능해짐

### 라우팅을 정의하는 법

- Next.js 라우팅은 파일 시스템을 기반으로 함
- app 기반 라우팅은 기존과 약간 다름
    - Next.js 12 이하
        - /pages/a/b.tsx 또는 /pages/a/b/index.tsx는 모두 동일한 주소로 변환됨
        - 파일명이 index라면 이 내용은 무시함
    - Next.js 13
        - /app/a/b는 /a/b로 변환되며 파일명은 무시됨
        - 폴더명까지만 주소로 변환됨
- app 디렉터리 내부 파일명은 라우팅 명칭에 아무 영향이 없음
- 가질 수 있는 파일명은 뒤이어 설명할 예약어로 제한됨

### layout.js

- 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미침
- 루트에는 단 하나의 layout을 둘 수 있으며 모든 페이지에 영향을 미치는 공통 레이아웃
- _app, _document를 하나로 대체할 수 있는 좋은 시작점
- _document에서 하던 CSS-in-JS의 초기화도 루트의 레이아웃에서 적용 가능
- _document.jsx에서만 처리할 수 있었던 부자연스러움이 사라짐
- layout은 app 디렉터리 내부에서는 예약어
- children은 props로 받아서 렌더링해야 함
- 내부에서 반드시 export default로 내보내는 컴포넌트가 있어야 함
- 내부에서도 api 요청 등 비동기 작업 수행 가능

### page.js

- page가 받는 props
    - params
    - searchParams
        - layout에서는 제공되지 않음 : layout은 페이지 탐색 중에는 리렌더링 수행 X
        - search parameter에 의존적인 작업을 해야 하면 반드시 page 내부에서 수행해야 함
- page의 규칙
    - app 디렉터리 내부의 예약어
    - 내부에서 export default로 내보내는 컴포넌트가 있어야 함

### error.js

- 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트
- 특정 라우팅별로 서로 다른 에러 UI 렌더링이 가능해짐
- 에러 바운더리는 클라이언트에서만 작동해 error 컴포넌트도 클라이언트 컴포넌트여야 함

### not-found.js

- 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용함
- 전체 앱에서 노출하려면 app/not-found.js를 생성해 사용하면 됨
- 서버 컴포넌트로 구성하면 됨

### loading.js

- Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용 가능

### route.js

- route.ts가 존재하는 폴더 내부에는 page.tsx가 존재할 수 없음
- route의 함수들이 받을 수 있는 파라미터
    - request : NextRequest 객체
    - context : params만을 가지고 있는 객체

# 11.2 리액트 서버 컴포넌트

- SSR과 완전히 다른 개념

## 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 리액트의 모든 컴포넌트는 클라이언트에서 작동하며, 브라우저에서 JS 코드 처리가 이뤄짐
- SSR은 미리 서버에서 DOM을 만들어 오고, 클라이언트에서는 하이드레이션을 진행함
- 이후 브라우저에서는 상태를 추적하고, 이벤트 핸들러는 DOM에 추가하고, 응답에 따라 렌더링 트리를 변경하기도 함
- 지금까지의 구조의 한계점
    - JS 번들 크기가 0인 컴포넌트를 만들 수 없다
        - 브라우저 환경에서 타사 라이브러리의 이용은 피할 수 없음
            
            ⇒ 서버에서는 해당 라이브러리를 실행한 결과와 컴포넌트 렌더링 결과물만 클라이언트에 제공하자
            
    - 백엔드 리소스에 대한 직접적 접근은 불가하다
        
        ⇒ 클라이언트에서 직접 백엔드에 접근해 원하는 데이터를 가져올 수 있게 하자
        
        - DB에 직접 액세스하거나 백엔드의 파일 시스템에 직접 접근하는 등 클라이언트에 데이터를 제공하기 위한 수고로움이 줄어들 것
        - 성능 광점에서 볼 때도 마찬가지로 백엔드에 접근할 수 있는 단계가 하나 줄어듬
    - 자동 코드 분할이 불가함
        - 일반적으로 lazy를 사용해 구현해 옴
            - lazy로 일일이 감싸는 것을 기억해야 함
            - 해당 컴포넌트가 호출되고 if문을 판단하기 전까지 어떤 지연 로딩한 컴포넌트 불러올지 결정 불가
        - 이 코드 분할을 서버에서 자동으로 수행해 준다면 어떤 컴포넌트를 미리 불러와 클라이언트에 내려줄지 서버에서 결정할 수 있다면 코드 분할의 이점을 100% 활용 가능
    - 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어려움
        - 데이터 불러오고 컴포넌트를 렌더링하는 것이 모두 서버에서 이뤄지므로 클라이언트에서 서버로 요청함으로써 발생하는 지연을 줄일 수 있고, 클라이언트에서는 반복적으로 요청을 수행할 필요도 없어짐
    - 추상화에 드는 비용이 증가함
        - 복잡한 추상화에 따른 결과물을 연산하는 작업을 서버에서 수행하면 코드 추상화에 따른 비용은 서버에서만 지불하면 됨
- SSR과 CSR의 장점을 모두 취하고자 하는 것이 `서버 컴포넌트`

## 11.2.2 서버 컴포넌트란?

- 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하며 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법
- 서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저에서 수행함
- 클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없음
    - 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 방법이 없어 호출 불가
- 서버 컴포넌트 vs 클라이언트 컴포넌트 vs 공용 컴포넌트
    - 서버 컴포넌트
        - 요청이 오면 그 순간 서버에서 딱 한 번 실행되므로 상태를 가질 수 없음. 상태를 가지는 useState, useReducer 등의 훅 사용 불가
        - 렌더링 생명주기도 사용 불가. 한번 렌더링되면 그걸로 끝이라 useEffect, useLayoutEffect를 사용 불가
        - 서버에서 제공할 수 있는 기능만 사용하는 훅은 사용 가능
        - 브라우저 아닌 서버에서만 실행되어 DOM API를 쓰거나 window, document 등에 접근 불가
        - 서버에서만 있는 데이터를 async/await로 접근 가능. 컴포넌트 자체가 async한 것이 가능함
        - 다른 서버 컴포넌트나 클라이언트 컴포넌트 렌더링 가능
    - 클라이언트 컴포넌트
        - 브라우저 환경에서만 실행되어 서버 컴포넌트나 서버 전용 훅, 유틸리티를 불러올 수 없음
        - 서버 컴포넌트 → 클라이언트 컴포넌트 → 서버 컴포넌트 렌더링 구조는 가능
            
            ⇒ 두 가지 예외 사항 제외하면 일반적으로 아는 리액트 컴포넌트와 같음
            
    - 공용 컴포넌트
        - 서버, 클라이언트 모두에서 사용 가능
        - 서버, 클라이언트 컴포넌트의 모든 제약을 받은 컴포넌트가 됨
- 리액트는 모든 것을 다 공용 컴포넌트로 판단해 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류함
- 클라이언트 컴포넌트 명시적으로 선언 시 “use client”라고 작성하면 됨
- 리액트 서버 컴포넌트는 여러 가지 제약 요소로 인해 번들러나 특정 프레임워크의 도움을 받는 것이 필수적

## 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

- SSR과 서버 컴포넌트 모두 채택하는 것도 가능해질 것
    - 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 SSR로 초기 HTML으로 빠르게 전달받을 수 있음
    - 둘은 대체제가 아닌 상호보완하는 개념으로 봐야할 것

## 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

- 작동 방식
    1. 서버가 렌더링 요청을 받음. 루트에 있는 컴포넌트는 항상 서버 컴포넌트
    2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화함. 
    서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타냄. 
    브라우저는 이후에 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행함.
    3. 브라우저가 리액트 컴포넌트 트리를 구성함. 
    브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나감.
- 특별한 점
    - 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어 브라우저에서는 되도록 빨리 사용자에게 결과물을 보여줄 수 있음
    - 컴포넌트들의 번들링이 별개로 돼 있어 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능해짐
    - 결과물이 HTML이 아닌 JSON 형태로 보내져 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 도와줌
- 서버 컴포넌트에서 클라이언트 컴포넌트로 props를 넘길 때 반드시 직렬화 가능한 데이터를 넘겨야 함
- 서버 컴포넌트는 리액트 컴포넌트가 가지고 있던 한계를 극복하기 위해 만들어졌으며 SSR과는 완전히 다른 개념

# 11.3 Next.js에서는 리액트 서버 컴포넌트

- Next.js가 13버전부터 서버 컴포넌트 지원
    - 기본적인 서버 컴포넌트의 제약은 동일
        - 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없음
        - 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능
        - 루트 컴포넌트는 무조건 서버 컴포넌트가 됨
        - page.js, layout.js는 반드시 서버 컴포넌트여야 하며, 서버 컴포넌트의 제약을 받음

## 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- getServerSideProps, getStaticProps, getInitialProp가 `/app` 내부에서는 삭제됨
- 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄짐
- fetch 요청에 대한 내용을 서버에서는 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 해당 데이터를 최대한 캐싱해 중복된 요청을 방지함

## 11.3.2 정적 렌더링과 동적 렌더링

- Next.js 13에서는 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게끔 해뒀고, 동적인 라우팅은 매번 서버 요청이 올 때마다 컴포넌트를 렌더링하도록 변경함
- `예제` 특정 API 엔드 포인트에서 데이터를 불러와 페이지에서 렌더링하는 구조를 가진 서버 컴포넌트
    - 빌드 시에 해당 주소로 미리 요청해 데이터 가져와 렌더링한 결과를 빌드에 넣어둠
    - 해당 주소를 정적으로 캐싱하지 않는 방법
        - no-cache 옵션 추가
        - Next.js에서 제공하는 옵션 추가
        - fetch 요청 이후에 렌더링을 수행함
        - next/headers나 next/cookie 같은 헤더 정보 쿠키 정보 → 동적 연산하는 걸로 인식해 정적 렌더링 대상에서 제외됨
        - getStaticPaths 흉내 : 새로운 함수인 generateStaticParams 사용
- fetch 옵션
    - fetch(URL, { cache: ‘force-cache’ })
        - 기본값으로 getStaticProps와 유사하게 불러온 데이터를 캐싱
    - fetch(URL, { cache: ‘no-store’ }), fetch(URL, { next: { revalidate: 0} })
        - getServerSideProps와 유사하게 캐싱하지 않고 매번 새로운 데이터 불러옴
    - fetch(URL, { next: { revalidate: 10 } })
        - getStaticProps에 revalite를 추가한 것과 동일
        - 유효시간 동안에는 캐싱하고 지나면 파기함

## 11.3.3 캐시와 mutating, 그리고 revalidating

- 캐시 전체적으로 무효화 : router.refresh() 사용
    - 히스토리에 영향 없이 서버에서 루트부터 데이터를 전체적으로 가져와 갱신함

## 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

- 스트리밍 : HTML을 작은 단위로 쪼개서 클라이언트로 점진적으로 보냄
- 일부라도 페이지와 인터랙션을 할 수 있음
    - TTFB(Time To First Byte)과 FCP(First Contentful Paint) 개선에 도움을 줌
- 활용 방법
    - 경로에 loading.tsx 배치
    - Suspense 배치
- 스트리밍 활용으로 서버 렌더링이 가능해지고, 리액트는 로딩이 끝난 컴포넌트 순서대로 하이드레이션을 수행해 가능한 한 사용자에게 빠르게 상호작용이 가능한 페이지 제공

# 11.4 웹팩의 대항마, 터보팩의 등장(beta)

- 웹팩의 후계자 터보팩 출시
- 웹팩 대비 최대 700배, Vite 대비 최대 10배 빠름
- 러스트 기반으로 작성돼 가능

# 11.5 서버 액션(alpha)

- Next.js 13.4.0에 서버 액션 출시
    - API를 굳이 생성하지 않아도 함수 수준에서 서버에 직접 접근해 데이터 요청 등 수행 가능
    - 특정 함수 실행 그 자체만을 서버에서 수행 가능
    - next.config.js에서 실험 기능을 활성화해야 함
    - “use server” 선언
    - 함수는 반드시 asyncdudi gka

## 11.5.1 form의 action

- `<form />` : action props를 추가해 이 양식 데이터를 처리할 URI 넘겨줄 수 있음
- form.action에 handleSubmit이라는 서버 액션을 만들어 props로 넘겨줌
- handleSubmit 이벤트를 발생시키는 것은 클라이언트지만 실제로 함수 자체가 수행되는 것은 서버가 됨

## 11.5.3 startTransition과의 연동

- useTransitiond에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있음
- useTransition 사용 시 이전과 동일한 로직 구현하면서도 page 단위의 loading.tsx를 사용하지 않아도 됨
- 컴포넌트 단위의 로딩 처리도 가능해짐
- revalidatePath과 같은 server mutation도 마찬가지로 처리할 수 있음

## 11.5.5 서버 액션 사용 시 주의할 점

- 클라이언트 컴포넌트 내에서 정의될 수 없음
- 클라이언트 컴포넌트에서 서버 액션 쓸 때는 ‘use server’로 서버 액션만 모여 있는 파일을 별도로 import해야 함
- props 형태로 서버 액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능함

# 11.6 그 밖의 변화

- 프로젝트 전체 라우트에서 쓸 수 있는 미들웨어가 강화됨
- SEO를 쉽게 작성할 수 있는 기능이 추가되었으며, 정적으로 내부 링크 분석 가능

# 11.7 Next.js 13 코드 맛보기

## 11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기

- Next.js 13과 리액트 18에서는 서버 컴포넌트라면 어디든 서버 관련 코드를 추가할 수 있게 됨
- 서버 컴포넌트에서 fetch를 수행하고, 이 fetch에 별다른 cache 옵션을 제공하지 않는다면 기존의 getServerSideProps와 매우 유사하게 작동함
- 리액트 18부터는 서버 컴포넌트의 렌더링 결과를 컴포넌트별로 직렬화된 데이터로 받아 이 데이터를 바탕으로 클라이언트에서 하이드레이션하는 데 사용함

## 11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기

- Next.js에서 app 디렉터리가 생겨나면서 getStaticProps와 getStaticPaths는 사라졌지만 이와 유사한 방식을 fetch의 cache를 이용해 구현 가능

## 11.7.3 로딩, 스트리밍, 서스펜스

- 스트리밍과 리액트의 Suspense를 활용해 컴포넌트가 렌더링 중이라는 것을 알 수 있음
