# 5.1 상태 관리는 왜 필요한가?

- `상태`
    - 어떠한 의미를 지닌 값
    - 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값
    - `UI`
        - 상호 작용이 가능한 모든 요소의 현재 값
        - 다크/라이트 모드, 라디오를 비롯한 각종 input, 알림창의 노출 여부
    - `URL`
        - 브라우저에서 관리되고 있는 상태값
        - roomId=123  ⇒ 이런 상태는 사용자의 라우팅에 따라 변경됨
    - `form`
        - 로딩 중, submit 여부, disabled, validation 등 모두가 상태로 관리됨
    - `서버에서 가져온 값`
        - 클라이언트에서 서버로 요청을 통해 가져온 값
        - ex. API 요청

## 5.1.1 리액트 상태 관리의 역사

- 리액트 : 단순히 UI를 만들기 위한 라이브러리이며 그 이상의 기능을 제공하지 않음

### Flux 패턴의 등장

- 리액트에서 전역 상태 관리
    - `Context API`
        - 순수 리액트에서 할 수 있는 전역 상태 관리
        - 엄밀히 말하면 상태 관리가 아닌 상태 주입
- 기존 MVC 패턴은 Model과 View가 많아질수록 복잡도가 증가함
    - 페이스북 팀 : 이 문제의 원인을 양방향 데이터 바인딩으로 봄
    - 뷰(HTML)가 모델(JS)을 변경할 수 있으며, 반대의 경우 모델도 뷰를 변경 가능
    - 페이스북 팀 : 양방향 아닌 단방양으로 데이터 흐름을 변경하는 것 제한 ⇒ Flux 패턴의 시작
- 용어
    - action
        - 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터 의미
        - 액션 타입과 데이터를 각각 정의해 디스패처로 보냄
    - dispatcher
        - 액션을 스토어에 보내는 역할
        - 콜백 함수 형태, 액션이 정의한 타입과 데이터를 모두 스토어에 보냄
    - store
        - 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가짐
        - 액션의 타입에 따라 어떻게 이를 변경할지 정의돼있음
    - view
        - 리액트의 컴포넌트에 해당하는 부분
        - 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할
        - 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트할 수 있음 ⇒ 뷰에서 액션을 호출하는 구조로 구성
- 단방향 데이터 흐름 : 불편함도 존재
    - 사용자의 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지도 코드로 작성해야 하므로 코드의 양이 많아지고 개발자도 수고로워짐
    - 데이터의 흐름 추적하기 쉽고 코드를 이해하기가 한결 수월해짐
- 리액트 : 대표적인 단방향 데이터 바인딩을 기반으로 한 라이브러리
    - 단방향 흐름을 정의하는 Flux 패턴과 잘 맞았음
- 리액트 기반 Flux의 특징 : 상태과 그 상태의 변경에 대한 흐름과 방식을 단방향으로 채택한 것

### 시장 지배자 리덕스의 등장

- `리덕스`
    - 최초에는 이 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나
    - 여기에 Elm 아키텍처를 도입함
    - `Elm`
        - 웹페이지를 선언적으로 작성하기 위한 언어
        - 아키텍처
            - `model` : 앱의 상태
            - `view` : 모델을 표현하는 HTML
            - `update` : 모델을 수정하는 방식
        - Flux와 마찬가지로 데이터 흐름을 세 가지로 분류
        - 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력함
        - 리덕스는 이 아키텍처의 영향을 받아 작성됨
    - 사용 방식
        - 하나의 상태 객체를 스토어에 저장
        - 이 객체를 업데이트하는 작업을 디스패치에 업데이트를 수행함
        - 이 작업은 reducer로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환 후 앱에 이 새롭운 상태를 전파하게 됨
        - 하나의 글로벌 상태 객체를 전파해 props drilling 해결 가능
        - 스토어 필요한 컴포넌트는 단지 connect 만으로 스토어에 바로 접근 가능
    - 불편함
        - 하고자 하는 일에 비해 보일러플레이트가 너무 많지만 지금은 간소화됨
    
    ⇒ react + redux는 일종의 표준처럼 굳어짐
    

### Context API와 useContext

- props drilling 발생, redux는 보일러플레이트가 부담스러움
- react 16.3
    - 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API 출시
    - Context Provider가 주입하는 상태를 원하는 곳에서 사용 가능
- 상태 관리가 아닌 주입을 도와줌
- 렌더링을 막아주는 기능도 존재하지 않아 주의가 필요

### 훅의 탄생, 그리고 React Query와 SWR

- 훅와 state의 등장 ⇒ React Query와 SWR 등장
    - 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리
    - API 호출 상태를 관리해 HTTP 요청에 특화된 상태 관리 라이브러리
- useSWR
    - 첫 번째 인수 : 조회할 API 주소
    - 두 번째 인수 : 조회에 사용되는 fetch
        
        ```jsx
        const { data, error } = useSWR(
          'https://api.foo.kr',
          fetcher
        )
        ```
        
    - 이후에 동일 키로 호출 시 캐시의 값을 활용함

### Recoil, Zustand, Jotai, Valtio에 이르기까지

- 훅을 활용해 상태를 가져오거나 관리할 수 있는 다양한 라이브러리가 등장
- 페이스북 팀의 Recoil부터 Jotai, Zustand, Valtio 등 다양한 라이브러리 등장
    - 훅을 활용해 작은 크기의 상태를 효율적으로 관리
    - peerDependencies로 리액트 16.8 버전 이상을 요구함
    - 리액트와의 연동을 전제로 작동해 별도로 다른 라이브러리를 설치하지 않아도 됨
- 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들고, 훅 지원으로 함수형 컴포넌트에서 손쉽게 사용할 수 있음

# 5.2 리액트 훅으로 시작하는 상태 관리

- Context API, useReducer, useState의 등장으로 컴포넌트에 걸쳐 재사용하거나 컴포넌트 내부에 걸쳐 상태 관리할 수 있는 방법들이 점차 등장합

## 5.2.1 가장 기본적인 방법: useState와 useReducer

- useState의 등장으로 여러 컴포넌트에 걸쳐 쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됨
    
    ```tsx
    fuction useCounter(initCount: number = 0) {
      const [counter, setCounter] = useState(initCount)
      
      function inc() {
    	  setCounter((prev) => prev + 1)
      }
      
      return { counter, inc }
    }
    ```
    
    - 훅 내부에서 관리해야 하는 상태가 복잡하거나 상태를 변경할 수 있는 시나리오가 다양해진다면 훅으로 코드를 격리해 제공할 수 있다는 장점이 더 크게 드러날 것
- useState는 useReducer로 구현됨
- useState나 useReducer
    - 모두 약간의 구현상의 차이가 있을 뿐, 두 훅 모두 지역 상태 관리를 위해 만들어짐
    - 이를 기반으로 하는 사용자 지정 훅의 한계는 훅 사용 시마다 컴포넌트별로 초기화되어 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없음
    - useState를 기반으로 한 상태는 `지역 상태` 이며, 이 상태는 해당 컴포넌트 내에서만 유효함
    - 지역 상태라는 한계 때문에 여러 컴포넌트에 걸쳐 공유하려면 컴포넌ㅌ트 트리 재설계 등의 수고로움 필요

## 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

- useState
    - 리액트가 만든 클로저 내부에서 관리되어 지역 상태로 생성됨
        
        ⇒ useState가 리액트 클로저가 아닌 다른 JS 실행 문맥 어디에선가 초기화되어 관리된다면?
        
- 함수 외부에서 상태를 참좌고 이를 통해 렌더링까지 자연스럽게 일어나려면 다음 조건을 만족해야 함
    1. 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 함
    2. 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고 상태 변화 시마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해야 함. 이 상태 감지는 이 상태를 참조하는 모든 컴포넌트에서 동일하게 작동해야 함
    3. 상태가 객체인 경우에 그 객체에 내가 감지하지 않는 값이 변해도 리렌더링이 발생해서는 안 됨

## 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

- Recoil, Jotai : Context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는 데 초점을 맞추고 있음
- Zustand: 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리
    - 하나의 큰 스토어는 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태 변경 시 이 상태를 구독하는 컴포넌트에 전파해 리렌더링을 알립는 방식

### 페이스북이 만든 상태 관리 라이브러리 Recoil

- RecoilRoot
    - Recoil을 사용하기 위해 최상단에 둬야 함
    - Recoil에서 생성되는 상태값을 저장하기 위한 스토어를 생성함
    - useStoreRef
        - ancestorStoreRef의 존재를 확인
        - Recoil에서 생성되는 atom과 같은 상태값을 저장하는 스토어를 의미
        - useStoreRef가 가리키는 것은 다름 아닌 AppContext가 가지고 있는 스토어
- atom
    - 상태를 나타내는 Recoil의 최소 단위
    - key를 필수로 가지며, 다른 atom과 구별하는 식별자가 되는 필수 값
    - 애플리케이션 내부에서 유일한 값
- useRecoilValue
    - atom의 값을 읽어오는 훅
    - getLoadable
        - Recoil이 가지고 있는 상태값을 가지고 있는 클래스인 loadable을 반환하는 함수
        - 이 값을 이전값과 비교해 렌더링이 필요한지 확인하기 위해 렌더링을 일으키지 않으면서 값을 저장할 수 있는 ref에 매번 저장함
    - useEffect를 통해 recoilValue가 변경됐을 때 forceUpdate를 호출해 렌더링을 강제로 일으킴
- useRecoilState
    - 값을 가져오고, 이 값을 변경할 수도 있는 훅
- 특징
    - selector 등의 다양한 비동기 작업을 지원하는 API를 제공
    - 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 처리 가능

### Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai

- Recoil의 atom 모델에 영감을 받아 만들어진 상태 관리 라이브러리
- 작은 단위의 상태를 위로 전파할 수 있는 구조
- 리액트 Context의 문제점인 불필요한 리렌더링이 일어난다는 문제를 해결핮고자 설계됨
- 개발자들이 메모이제이션이나 최적화를 거치지 않아도 리렌더링이 발생되지 않도록 설계됨
- atom
    - atom 하나만으로도, 이에 파생된 상태를 만들 수도 있음
    - 별도의 key를 넘겨주지 않아도 됨
    - config라는 객체를 반환함
        - init, read, write만 존재
    - Jotai에서의 atom에 따로 상태를 저장하고 있지 않음
        
        ⇒ useAtomValue에 저장
        
- useAtom
    - useState와 동일한 형태의 배열을 반환
- 특징
    - Recoil의 atom 개념을 도입하면서도 API가 간결함
    - 키를 추상화해 사용자가 별도로 관리할 필요가 없음
        
        ⇒ 객체의 참조를 통해 값을 관리
        
    - 객체의 참조를 WeakMap에 보관해 해당 객체 자체가 변경되지 않는 한 별도의 키 없이도 객체의 참조를 통해 값을 관리할 수 있음
    - selector 없이도 파생된 상태를 만들 수 있음

### 작고 빠르며 확장에도 유연한 Zustand

- 리덕스에 여감을 받음
- 하나의 스토어를 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리함
- state의 값을 useState 외부에서 관리함
- partial와 replace
    - partial : state의 일부분만 변경하고 싶을 때 사용
    - replace : state를 완전히 새로운 값으로 변경하고 싶을 때 사용
- getState: 클로저의 최신 값을 가져오기 위해 함수로 만들어져 있음
- 특징
    - 특별히 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있음
    - Zustand의 라이브러리 크기도 2.9kB로 작음
    - Jotai와 같이 TS 기반으로 작성돼 별도 @types 설치나 임의로 작성된 d.ts에 대한 우려 없이 TS를 자연스럽게 쓸 수 있음
    - 미들웨어를 지원해 sessionStorage에 추가로 저장하는 등의 추가적인 작업을 정의할 수도 있음

## 5.2.5 정리

- 상태 관리 방식에는 차이가 있지만 리액트에서 리렌더링을 일으키기 위한 방식은 제한적이라 리렌더링을 만드는 방법은 모두 거의 동일함
- 메인테이너가 많고 다운로드가 활발하며 이슈가 관리가 잘되고 있는 라이브러리를 선택하는 것이 좋음
