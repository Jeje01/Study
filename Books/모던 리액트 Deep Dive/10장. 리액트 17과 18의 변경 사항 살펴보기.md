# 10.1 리액트 17 버전 살펴보기

- 리액트 17버전 : 16과 다르게 새로 추가된 기능이 없으며 호환성이 깨지는 변경 사항, 즉 기존 코드 수정이 필요한 변경 사항을 최소화함
    - 16 → 17 버전 업은 큰 부담이 없음

## 10.1.1 리액트의 점진적인 업그레이드

- 리액트 17 버전부터는 점진적인 업그레이드 가능
    - 일부 컴포넌트 변경
- 리액트 16과 17 모두 지원하는 컴포넌트나 훅이라면 버전이 다른 두 리액트에서도 무리 없이 사용 가능

## 10.1.2 이벤트 위임 방식의 변경

- 리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착함 ⇒ 이벤트 위임
- 이벤트 구성 단계
    1. 캡처 : 트리 최상단 요소 → 실제 이벤트 발생 타깃 요소까지 내려가는 것
    2. 타깃 : 이벤트 핸들러가 타깃 노드에 도달하는 단계. 여기서 이벤트가 호출됨
    3. 버블링 : 이벤트 발생 요소 → 최상위 요소
    
    ⇒ 이벤트 위임 : 이러한 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것
    
- 리액트는 최초 릴리스부터 이러한 이벤트 위임을 적극적으로 사용함
- 리액트 16까지는 모두 document에서 수행됨
- 17부터는 모두 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀜
- 서로 다른 리액트 버전에서 발생할 수 있는 문제 해결 위해 이벤트 위임의 대상을 document에서 컴포넌트의 최상위로 변경함
- 각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리되므로 이벤트 버블링으로 인한 혼선 방지 가능
- jQuery 같은 다른 라이브러리와 리액트 16 등이 혼재돼 있는 상황에도 동일한 문제 발생 가능
- 리액트 16에서는 document와 리액트가 렌더링되는 루트 컴포넌트 사이에서 이벤트를 막는 코드 추가 시 리액트의 모든 핸들러가 작동하지 않게 막을 수 있었음

## 10.1.3 import React from ‘react’가 더 이상 필요 없다: 새로운 JSX transform

- 리액트 17부터 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됨
- 장점
    - import 불필요
    - 번들링 크기 작아짐
    - 컴포넌트 작성 간결해짐
- JSX 변환 시 필요한 모듈인 react/jsx-runtime을 불러오는 require 구문도 같이 추가됨

## 10.1.4 그 외의 주요 변경 사항

- 이벤트 폴링 제거
    - 16 이하 : 이벤트 폴링을 통해 서로 다른 이벤트 간 이벤트 객체를 재사용
    - 재사용하는 사이에 모든 이벤트 필드를 null로 변경
    - 한번 이벤트 핸들러를 호출한 SyntheticEvent는 이후 재사용을 위해 null로 초기화됨
- useEffect 클린업 함수의 비동기 실행
    - useEffect에 있는 클린업 함수는 리액트 16까지는 동기적으로 처리됨
    - 17부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행됨
- 컴포넌트의 undefined 반홚에 대한 일관적인 처리
    - 리액트 16과 17 버전은 컴포넌트 내부에서 undefined를 반환하면 오류가 발생함
    - 리액트 17부터는 에러가 정상적으로 발생함
    - 18부터는 undefined를 반환해도 에러가 발생하지 않음

## 10.1.5 정리

- 리액트 17 버전 : 사용자에게 영향을 미칠 수 있는 큰 변화를 최소화하고 다음 버전 업을 위한 버전 업 정도로 마무리됨

# 10.2 리액트 18 버전 살펴보기

- 리액트 17에서 하지 못했던 다양한 기능이 추가됨
- 가장 큰 변경점 : 동시성 지원

## 10.2.1 새로 추가된 훅 살펴보기

- 새로운 훅이 대거 추가됨
    
    ⇒ 함수형 컴포넌트 사용이 주를 이룰 것이라는 리액트 팀의 방향성
    

### useId

- 컴포넌트별로 유니크한 값을 생성하는 새로운 훅
- 기존 : 서버에서 렌더링했을 때의 값과 클라이언트에서 해당 결과물을 받고 하이드레이션 했을 때의 값이 다름
- useId 사용시 클라이언트와 서버에서 불일치를 피하며 컴포넌트 내부의 고유한 값을 생성할 수 있게 됨

### useTransition

- UI 변경을 가로막지 않고 상태를 업데이트할 수 있음
- 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있음
- 동시성 지원

### useDeferredValue

- 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
- 디바운스와 비슷하지만 다른점
    - 디바운스 : 고정된 지연 시간 필요
    - useDeferredValue : 첫 번째 렌더링이 완료된 이후에 이 훅으로 지연된 렌더링 수행
        - 중단 가능, 인터렉션 차단하지 않음

### useSyncExternalStore

- useSubscription의 구현이 리액트 18에 이르러서 대체된 것
- `tearing` : 하나의 state 값이 있음에도 서로 다른 값을 기준으로 렌더링되는 현상
    - 리액트 18에서는 useTransition, useDefferedValue의 훅처럼 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해져 동시성 이슈 발생 가능
    - 리액트의 클로저 범위 밖에 있는 관리 범위 밖에 있는 값에서 발생 가능
        - 글로벌 변수, document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부 상태 관리 라이브러리 등이 해당
        - useState나 useReducer가 아닌 모든 것들 : 외부 데이터 소스
    - 데이터 소스에 리액트에서 추구하는 동시성 처리가 추가돼 있지 않다면 tearing 현상이 발생 가능
    
    ⇒ 이 문제를 해결하기 위한 훅이 `useSyncExternalStore`
    
- 코드
    
    ```
    useSyncExternalStore(
      subscribe: (callback) => Unsubscribe
      getSnapshot: () => State
    ) => State
    ```
    
    - 첫 번째 인수 : 콜백 함수를 받아 스토어에 등록하는 용도
    - 두 번째 인수 : 컴포넌트에 필요한현재 스토어의 데이터를 반환하는 함수
    - 옵셔널 값 : SSR 시에 내부 리액트를 하이드레이션하는 도중에만 사용됨
- 예시 ) 현재 윈도우의 innerWidth를 확인하는 코드
    - innerWidth는 리액트 외부에 있는 값이라 이 값 변경 여부를 확인해 리렌더링까지 이어지게 하려면 useSyncExternalStore를 사용하는 것이 매우 적절
- 외부에 상태가 있는 데이터에는 반드시 useSyncExternalStore를 사용해 값을 가져와야 startTransition 등으로 인한 테어링 현상이 발생하지 않음
- 사용 중인 관리 라이브러리가 외부에서 상태를 관리한다면 이 훅을 통해 외부 데이터 소스의 변경을 추적 중인지 확인해야 함
    - 그렇지 않다면 렌더링 중간에 발생하는 값 업데이트를 적절하게 처리하지 못하고 테어링 현상이 발생할 것

### useInsertionEffect

- CSS-in-js 라이브러리를 위한 훅
- CSS 추가 및 수정은 브라우저에서 렌더링하는 작업 대부분을 다시 계산해 작업해야 하는데, 이는 리액트 관점으로 본다면 모든 리액트 컴포넌트에 영향을 미칠 수도 있는 매우 무거운 작업
- 리액트 17과 styled-components에서는 클라이언트 렌더링 시에 이러한 작업이 발생하지 않도록 서버 사이드에서 스타일 코드를 삽입함
- 이러한 작업을 훅에서 할 수 있도록 도와주는 훅
- useEffect와 구조는 동일하지만 실행 시점이 차이남
    - DOM이 실제로 변경되기 전에 동기적으로 실행됨
- 브라우저가 레이아웃을 계산하기 전에 실행될 수 있게끔 해서 더 자연스러운 스타일 삽입이 가능해짐
    
    ⇒ 브라우저가 스타일 입힌 후 DOM을 재계산하지 않아도 됨
    
    ```
    세 가지의 실행 순서
    1. useInsertionEffect
    2. useLayoutEffect
    3. useEffect
    ```
    
- 실제 애플리케이션 코드 작성에는 사용할 일이 거의 없음

## 10.2.2 react-dom/client

- 클라이언트에서 리액트 트리를 만들 때 사용되는 API가 변경됨

### createRoot

- 기존의 react-dom에 있던 render 메서드를 대체할 새로운 메서드
- 리액트 18 기능 사용 시 createRoot와 render를 함께 사용해야 함

```jsx
// 18 미만
RectDOM.render(<App />, container)

// 18 이후
const root = ReactDOM.createRoot(container)
root.render(<App />
```

### hydrateRoot

- SSR 앱에서 hydration을 하기 위한 새로운 메서드
- SSR 직접 구현 시 수정해야 함

## 10.2.3 react-dom/server

- 서버에서도 컴포넌트 생성 API에 변경이 있음

### renderToPipeableStream

- 리액트 컴포넌트를 HTML로 렌더링하는 메서드
- 스트림 지원, HTML을 점진적으로 렌더링, 클라이언트에서는 중간에 script를 삽입 가능
- 서버에서는 Suspense를 사용해 빠르게 렌더링 필요한 부분을 먼저 렌더링, 값비싼 연산이 필요한 부분은 이후에 렌더링 가능

### renderToReadableStream

- 웹 스트림을 기반으로 작동함

## 10.2.4 자동 배치(Automatic Batching)

- 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법
- 예시 ) 버튼 클릭 한 번에 두 개 이상의 state를 동시에 업데이트할 때 하나의 리렌더링으로 묶어서 수행 가능

## 10.2.5 더욱 엄격해진 엄격 모드

### 리액트의 엄격 모드

- 리액트에서 제공하는 컴포넌트 중 하나
- 리액트 앱에서 발생 가능한 잠재 버그를 찾는 데 도움이 되는 컴포넌트

### 리액트 18에서 추가된 엄격 모드

- 사용자가 뒤로가기를 했다가 다시 현재 화면으로 돌아왔을 때, 리액트가 즉시 이전의 상태를 그대로 유지해 표시할 준비를 하는 기능이 추가될 예정
- 컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두 번째 마운트에서 이전 상태를 복원하게 되며, 개발 모드에서만 적용됨
- useEffect 사용 시 반드시 적절한 cleanup 함수 배치로 반복 실행 가능한 useEffect로부터 최대한 자유로운 컴포넌트를 만드는 것이 좋음

## 10.2.6 Suspense 기능 강화

- lazy와 Suspense는 한 쌍으로 사용됐으며, 초기 렌더링 속도 향상에 도움을 줌
- 18 이전의 Suspense의 문제점
    - 컴포넌트가 보이기도 전에 useEffect가 실행됨
    - 서버에서 사용할 수 없었음
- 18 버전
    - 컴포넌트가 실제로 화면에 노출될 때 effect가 실행됨
    - Suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행됨
    - 서버에서도 실행 가능
    - Suspense 내에 스로틀링이 추가됨

## 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- Promise, Symbol, Object.assign 등 리액트 사용 코드에서 최신 JS 기능 사용 가능

## 10.2.8 그 밖에 알아두면 좋은 변경사항

- 컴포넌트에서 undefined 반환 시에도 에러 발생 않고 null 반환과 동일하게 처리됨
- <Suspense fallback={undefined}>도 null과 동일하게 처리됨
- renderToNodeStream이 지원 중단, renderToPipeableStream 사용이 권장됨

## 10.2.9 정리

- 리액트 18 버전 업의 핵심은 동시성 렌더링
- 외부 라이브러리가 이를 지원하는지 확인이 필요함
