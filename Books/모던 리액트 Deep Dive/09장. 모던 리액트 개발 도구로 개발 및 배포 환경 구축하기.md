# 9.1 Next.js로 리액트 개발 환경 구축하기

- create-react-app은 더 이상 유지보수되지 않을 가능성이 큼
    - 대안(create-next-app)이나 아무것도 없는 상태에서 구축하는 방법을 공부해야함

## 9.1.1 create-next-app 없이 하나씩 구축하기

1. npm init 실행으로 package.json 만드는 CLI 실행
    
    ⇒ package.json이 생성돼있음
    
2. Next.js 프로젝트 실행에 필요한 핵심 라이브러리인 react, react-dom, next 설치
3. devDependencies에 필요한 패키지 설치
    - typescript, @types/react, @types/react-dom
    - Node.js의 타입 사용을 위한 @types/node
    - ESLint 사용에 필요한 eslint, eslint-config-next

## 9.1.2 tsconfig.json 작성하기

- npm 설정을 package.json에서 하는 것처럼 타입스크립트 설정은 tsconfig.json에 기록
- JSON 최상단에 $schema 키를 넣으면 JSON 파일에 대한 정보를 알려줘 자동 완성 가능
- tsconfig.json 옵션
    - compilerOptions: TS → JS 컴파일 시 사용
        - target : TS가 변환을 목표로 하는 언어의 버전
        - 폴리필까지는 지원하지 않음
    - lib: 가장 최신 버전을 의미하는 esnext 추가 시 target은 es5라 할지라도 신규 기능에 대한 API 정보가 확인 가능해 에러가 발생하지 않음
    - allowJs : TS가 JS 파일 또한 컴파일할지 결정
    - skipLibCheck: 라이브러리에서 제공하는 d.ts에 대한 검사 여부 결정
    - strict: TS 컴파일러의 엄격 모드 제어
    - noEmit: 컴파일하지 않고 타입 체크만 함

## 9.1.3 next.config.js 작성하기

- Next.js 설정을 위함
- 옵션
    - reactStrictMode: 리액트의 엄격 모드를 활성화함
    - poweredByHeader: 일반적으로 보안 취약점으로 취급되는 X-Powered-By 헤더를 제거
    - eslint.ignoreDuringBuilds: 빌드 시에 ESLint를 무시함

## 9.1.4 ESLint와 Prettier 설정하기

- JS 코딩은 정적 분석에 크게 의존 → ESLint 없이는 코딩하기가 어려움
- eslint-config-next는 단순히 코드에 있을 잠재적인 문제를 확인할 뿐, 띄어쓰기나 줄바꿈 등 코드의 스타일링을 정의해 주지는 않음
- 코드 스타일링은 @titicaca/eslint-config-triple 설치해 사용 가능

## 9.1.5 스타일 설정하기

- styled-components 사용하기
- swc에 styles-components를 사용한다는 것을 알리기 위해 styledComponents: true를 next.config.js에 추가함
    
    ⇒ swc가 styled-components를 사용하는 코드를 더 빠르게 변환함
    

## 9.1.6 애플리케이션 코드 작성

- 폴더 구조: pages, components, hooks, types, utils 등
- Next.js 애플리케이션의 폴더 구조 : src/pages 하단에 실제 페이지 라우팅과 관련된 파일을 기재해야 한다는 컨벤션만 지키면 됨
- 논의 후 누구나 쉽게 이해할 수 있으며, 관심사 분리가 명확하다면 어떠한 구조라도 크게 문제되지 않음
- 모든 폴더에 tsconfig.json을 활용해 적절한 경로 별칭(path alias)을 적용한다면 코드 내에서의 가독성 또한 확보 가능
- Next.js 프로젝트 실행, 빌드, 린트와 관련된 명령어를 package.json에 기재한 모든 준비를 마치게 됨

## 9.1.7 정리

- 요즘 MFA를 지향하며 프로젝트 구축하는 일이 잦아짐
- 프로젝트 세팅 효율화하는 방법
    1. Template repository 생성 후 사용
    2. 나만의 create-***-app 만들기
        - cli 패키지로 만들면 사용자의 입력을 받아 서로 다른 패키지 생성 가능
        - 조직 내에 MFA 지향, 앞으로 생성할 프로젝트 많다면 충분히 검토 가능

# 9.2 깃허브 100% 활용하기

## 9.2.1 깃허브 액션으로 CI 환경 구축하기

- `CI`
    - 코드의 변화를 모으고 관리하는 코드 중앙 저장소에서, 여러 기여자가 기여한 코드를 지속적으로 빌드하고 테스트해 코드의 정합성을 확인하는 과정
    - 핵심 : 저장소에서 코드의 변화가 있을 때마다 전체 소프트웨어의 정합성을 확인하기 위한 작업을 자동으로 실행해야 함
        - 자동으로 실행해야 하는 작업 : 테스트, 빌드, 정적 분석, 보안 취약점 분석 등
    - `젠킨스` : 과거 가장 자주 쓰인 솔루션이지만 번거로운 측면이 많았음
    - `깃허브 액션` : 대안으로 떠오르는 것
        - 깃허브에서 출시한 SaaS, 깃허브 저장소와 함께 사용할 수 있는 강력한 도구
        - 본래 목적
            - 깃허브의 어떤 브랜치에 푸시가 발생하면 빌드를 수행함
            - 깃허브의 특정 브랜치가 메인 브랜치를 대상으로 풀 리퀘스트가 열리면 빌드, 테스트, 정적 분석을 수행함
        - 다른 CI/CD 솔루션을 대체할 수 있음
- F/E 애플리케이션
    - 저장소에 있는 코드만으로 테스트, 빌드, 정적 분석 등 CI에 필요한 대부분의 기능을 손쉽게 구현 가능
    - 하나의 저장소에서 빠르고 다양한 CI 환경 구축할 때는 깃허브 액션이 훨씬 경제적
- 깃허브 액션은 깃허브 저장소에서만 사용 가능하며, 제한적인 환경에서만 무료로 사용 가능

### 깃허브 액션의 기본 개념

- `러너` : 파일로 작성된 깃허브 액션이 실행되는 서버. 공용 깃허브 액션 서버를 기본적으로 이용하며, 별도의 러너를 구축해 자체 운영 가능
- `액션` : 러너에서 실행되는 하나의 작업 단위. yaml 파일로 작성된 내용이 하나의 액션
- `이벤트` : 깃허브 액션의 실행을 일으키는 이벤트를 의미함. 이벤트를 지정할 수 있으며 특정 브랜치 지정하는 이벤트도 가능
    - pull_request, issues, push, push, schedule
- `잡` : 하나의 러너에서 실행되느 여러 스텝의 모음을 의미함. 하나의 액션에서 여러 잡 생성 가능. 내부 가상머신에서 각 잡은 병렬로 실행됨
- `스텝` : 잡 내부에서 일너나는 하나하나의 작업을 의미함. 병렬로 일어나지 않음
- 스텝들을 엮어서 잡을 만들고, 여러 개의 잡은 병렬로 실행되며, 잡을 하나 이상 모아둔 것이 액션. 액션을 실행하는 것이 러너

### 깃허브 액션 작성하기

- 액션을 작성하려면 저장소의 루트에 .github/workflows 폴더 생성 후 내부에 파일을 작성
- Prettier가 설치돼 있다면 yaml 파일도 함께 포함시켜 코드 스타일 유지하는 것이 좋음
- yaml 파일 설정
    - `name`: 액션의 이름
    - `run-name`: 액션이 실행될 때 구별할 수 있는 타이틀명
    - `on`: 필수 값, 언제 이 액션을 실행할지 정의함
    - `jobs`: 필수값, 해당 액션에서 수행할 잡 의미함. 여러 개 지정 시 병렬로 실행됨
- 액션 작성
    - 저장소에 yaml 파일 하나 추가하는 것만으로 CI를 구축할 수 있어 용이함
    - 깃헙 PR에 댓글 달기, 일정 시간마다 특정 작업 수행하기, 배포 서비스와 연동해 자동으로 배포 실행하기, 이미지 추가 시마다 이미지 최적화 등 가능
    - 액션을 추가해 자동화 처리, 빌드 확인, Prettier, ESLint, 테스트 등 자동화 가능
- 브랜치 보호 규칙
    - 머지하기 전에 꼭 성공해야 하는 액션이 있다면 별도로 저장소에 브랜치 보호 규칙 추가 가능
    - 머지 조건을 걸어두면 기본 브랜치에는 항상 테스트, 빌드 등 CI가 성공한 코드만 푸시 가능해 정합성 확보 가능

## 9.2.2 직접 작성하지 않고 유용한 액션과 깃허브 앱 가져다 쓰기

- 깃헙에서 Marketplaces를 통해 여러 사용자가 만들어 놓은 액션을 쉽게 사용 가능하도록 함

### 깃허브에서 제공하는 기본 액션

- actions/checkout
- actions/setup-node
- actions/github-script
- actions/staleactions/dependency-review-action
- github/codeql-action

### calibreapp/image-actions

- 저장소에 포함된 이미지를 최적화하는 액션
- PR로 올라온 이미지를 sharp 패키지를 이용해 거의 무손실로 압축해 다시 커밋해줌
- 저장소 자체의 이미지 크기를 줄인다면 pull할 때 부담이 덜어짐
- imgbot이라는 앱도 사용 가능

### lirantal/is-website-vulnerable

- 특정 웹사이트를 방문해 해당 웹사이트에 라이브러리 취약점이 존재하는지 확인

### Lighthous CI

- 구글에서 제공하는 액션
- 프로젝트의 URL을 방문해 라이트하우스 검사를 실행함
- 설정을 통해 라이트하우스 실행 결과가 일정 점수 미만이 되면 테스트 코드의 assert와 비슷하게 에러를 발생시키거나, 자체 라이트하우스 분석 서버를 만들어 별도로 분석 프로세스 실행 가능
- PR을 통해 개발된 서비스의 성능 지표를 매번 노출함

## 9.2.3 깃허브 Dependabot으로 보안 취약점 해결하기

- `Dependabot`: 깃헙에서 제공하는 강력한 기능
    - 의존성에 문제가 있다면 알려주고 가능하면 PR까지 열어줌

### package.json의 dependencies 이해하기

- 시맨틱 버저닝
    - 주,부,수로 구성됨
        1. 주 변경: 기존 버전과 호환되지 않게 API가 변경
        2. 부 변경: 기존 버전과 호환되며 새로운 기능 추가
        3. 수 변경: 기본 버전과 호환되며 버그를 수정
    - 0으로 시작: 실험 버전 라이브러리
- react 버전 예시
    - react@16.0.0: 특수 기호 없다면 정확히 해당 버전에 대해서만 의존함
    - react@^16.0.0: 16.0.0과 호환되는 버전, 16.0.0부터 17.0.0 미만
    - react@~16.0.0: 패치 버전에 대해서만 호환, 16.0.0부터 16.1.0 미만
- 의존성
    
    
    |  | npm install 시 | 실행 시 꼭 필요함 | 예시 |
    | --- | --- | --- | --- |
    | dependencies | 설치됨 | O | react, react-dom, next |
    | devDependencies | 설치됨
    —save-dev | X (개발 시 필요) | eslint, jest, typescript |
    | peerDependencies |  | 호환성 위해 필요함 |  |
    - 패키지 구분에 의문
        1. 번들러의 존재 : 동일하게 node_modules에 설치되어 최종 결과물에 영향 X
        2. 복잡해진 개발 파이프라인
            - 과거라면 npm install —only=production만으로 빌드와 실행이 돼야 하지만
            - typescript 관련 패키지가 devDependencies에 선언되어 tsc가 실행되지 못함
        - 경계가 모호해짐
        - npm에 업로드할 패키지 개발 시에는 구분이 중요해짐

### Dependabot으로 취약점 해결하기

- 취약점이 있는 예제 앱 설치
    - 각종 vulnerabilities가 발견됨
    - 탐지를 위해 원격 저장소에 푸시
    - 시간이 지나면서 보안 취약점이 하나둘씩 발견되는 것이 일반적
- 개별 취약점 살펴보기
    - Dependabot의 취약점: Critical, High, Moderate, Low 4단계로 분류됨
    - 취약점을 발견한 파일의 경로 보여줌
    - 바로 수정 가능하다면 PR 생성해줌
- 직접적으로 영향이 없을 것으로 판단된다면 시급성 낮춰서 대응하는 것이 좋음
    - 취약점이 있는 패키지도 취약점 발생 시나리오대로 사용하지 않으면 문제없음
    - ex. browserlist : 개발자만 작성 가능하므로 실제 위협이 되긴 어려움
- 취약점 해결하기
    - PR이 생성된 경우 가장 쉽게 해결 가능
- 정리
    - 의존성 관련 이슈 방지 : 의존성을 최소한으로 유지
    - dependencies와 node_modules의 크기가 커질수록 위협에 노출될 확률 또한 높아짐
    - 가능한 내재화 가능한 모듈은 내재화하고, 의존성을 최소한으로 유지하는 것이 좋음
    - 의존성 최소화 불가 시, 활발하게 유지보수되는 패키지를 사용해야 함

# 9.3 리액트 애플리케이션 배포하기

- 가장 손쉽고 빠르고 안정적으로 배포할 수 있는 몇 가지 SaaS 서비스 소개

## 9.3.1 Netlify

- 웹 앱을 배포할 수 있게 도와주는 클라우드 컴퓨팅 서비스
- 널리 알려진 정적 웹사이트 배포 서비스

### create-react-app으로 생성한 앱 배포하기

1. 저장소 불러오기
2. 빌드 및 배포 관련 설정 추가

### create-next-app으로 생성한 앱 배포하기

- Next.js 앱 배포 시 약간의 설정이 더 필요함
- Netlify는 ‘정적 웨사이트’를 배포하고 서비스하기 위해 탄생
- Next.js는 일반적으로 서버가 필요한 서버 사이드 앱을 서비스해 추가 설정이 필요함
1. 앱 루트에 netlify.toml 파일 생성
    1. TOML: Tom’s Obvious, Minimal Language, 최소한의 설정 관련 내용 작성 위함

### 추가 기능

- 무료 기능
    - 알림 : 채널 선택 가능
    - PR 생성 시 Preview를 배포해 PR에 알려줌
    - 도메인 연결
    - 서비스 통합: Sentry, redis, Aloglia(검색) 등 연계 가능
    - 서버리스 함수: Netlify에서 제공하는 규격을 준수해서 함수 생성 시 서버 없이도 웹에서 실행 가능
    - Identity: 서비스 이용 시 사용자 초대해 가입시키고 특정 API를 활용해 해당 유저에 대한 인증 처리 가능
    - 사용자 초대: 팀에 개발자 초대 가능

### 가격

- 무료 사용시 제약
    - 대역폭: 월 최대 100GB
    - 빌드 시간: 최대 300분
    - 동시 빌드: 여러 개 사이트 운영 시 한 번에 한 곳만 빌드 가능

## 9.3.2 Vercel

- Vercel: Next.js, Turborepo, SWC를 만든 Netlify와 비슷한 클라우드 플랫폼 서비스

### create-react-app으로 생성한 앱 배포하기

- Vercel은 디렉토리 직접 입력하지 않고 선택 가능
- 원하는 프레임워크를 선택해야 함

### create-next-app으로 생성한 앱 배포하기

- Vercel은 Next.js 서비스를 별도의 설정 없이 배포할 수 있음

### 추가 기능

- 알림 : Preview 배포 볼 수 있고, 실제 배포의 성공 실패 여부 볼 수 있음
- Serverless Function: 서버 없이 함수를 클라우드에 구축해 실행 가능, Next.js에서 제공하는 /pages/api의 내용도 이 함수로 구분돼 접근 로그나 오류 확인 가능
    - vercel이 Next.js의 api를 별도의 서버리스 함수로 인식하기 때문
- 다양한 템플릿: 별도의 코드 작성 없이도 구축할 수 있는 기본적인 웹사이트를 제공함

### 가격

- 무료 사용 가능
    - 대역폭: 월 최대 100GB
    - 이미지 최적화: 사이트에서 제공해 주는 이미지 최적화하는데, 1000개로 제한함
    - 서버리스 함수: 함수의 총 실행 시간이 100GB로 제한되며, 함수 실행 시간은 10초 이내로 제한함
    - 동시에 하나만 빌드 가능
    - 하루에 배포 100개로 제한

## 9.3.3 DigitalOcean

- 미국의 클라우드 컴퓨팅, 호스팅 플랫폼 업체
- Gtihub Student Pack에 포함됨
- 다양한 리소스에 대해 문서화 상세함
- Autodeploy 항목 체크 시 브랜치에 푸시가 일어날 때마다 자동으로 재배포됨

### 추가 기능

- 알람: 깃헙 외 이메일, 슬랙으로의 알림 지원
- 컨테이너에 직접 접근: 실제 서비스가 실행되고 있는 컨테이너에 직접 접근 가능
- 마켓플레이스: 컨테이너 제공에 초점이 맞춰져있는 앱이 많음
- 도메인 연결 가능
- 비교
    - Vercel, Netlify: 정적 웹사이트 배포에 초점
    - DigitalOcean: AWS, Google Cloud Platform과 비슷하게 조금 더 다양한 클라우드 컴퓨팅 서비스 제공함
- 제공하는 클라우드 컴퓨팅 서비스
    - Droplets: DigitalOcean의 클라우드 컴퓨팅 솔루션, 리눅스 기반 가상머신을 쉽게 생성 및 운영 간으하게 함
    - Functions: 서버리스 함수 생성해 클라우드 환경에서 실행 가능하게 함
    - Kubernetes: 쿠버네티스를 이용해 클러스터를 생성하고 이를 관리할 수 있게 함
    - Database와 Spaces: 데이터베이스 생성, 정적 파일을 업로드할 수 있는 스토리지 제공

### 가격

- 앱을 구성하는 컨테이너의 스펙, 앱의 개수에 따라 가격이 달라짐
- 앱의 개수가 많거나 성능에 신경을 더 써야하면 Netfliy, Vercel이 더 나을 수 있음

## 9.3.4 정리

- 트래픽이 제한적인 서비스, 빠르게 배포해 확인하고 싶은 MVP 서비스: 클라우드 서비스 활용 배포 추천
- 개발 중인 앱의 Next.js 버전, 자금 상황, 배포해야하는 웹 앱의 개수 등 고려해 판단 필요함
- 선택한 서비스를 다시 이동하는 것은 쉽지 않아 신중히 선택해 판단해야 함

# 9.4 리액트 애플리케이션 도커라이즈하기

- 앞선 방법
    - 트래픽이 적은 개인용 프로젝트, 테스트용, 어드민 페이지, MVP 프로젝트 만드는데 적합
    - 본격적으로 사용자에게 서비스하기 위한 웹 앱을 서비스하는데는 적절하지 않음
    - 커스터마이징하는데 제약이 있음
        - ex. NGINX와 같이 서버에 대한 자세한 설정 추가 기능까지 제공하는 서비스는 많지 않음
    - 유연하지 못한 비용 체계도 문제임
- 과거 웹 앱 배포
    1. 직접 장비를 준비
    2. 장비에 앱 구동에 필요한 각종 파일 설치
    3. 소스를 다운로드해서 설치
- 요즘 : 앱을 하나의 컨테이너로 만들어서 빠르게 배포하는 것이 일반적임
    
    ⇒ 컨테이너를 만드는 데 사용되는 것이 도커
    
- 도커
    - 운영에 필요한 앱을 격리해 컨테이너로 만드는데 이용하는 소프트웨어
    - 어디서든 실행 가능한 이미지 상태로 앱 준비 시 어디서든 웹 앱 배포 가능
    - Vercel, Netlify와 같이 특정 배포 서비스에 종속적이지 않은 상태로 유연하게 관리 가능
- 도커로 앱 만들어 관리하는 방법을 살펴볼 예정
    - 배포할 클라우드 플랫폼: Google Cloud Platform

## 9.4.1 리액트 앱을 도커라이즈하는 방법

- 도커라이즈: 앱을 도커 이미지로 만드는 과정
    - 앱을 신속히 구축해 배포할 수 있는 상태로 준비하는 것

### 도커란?

- 도커 홈페이지의 <metx> 태그 중 <description>
    
    ```
    도커는 개발자가 모던 앱을 구축, 공유, 실행하는 것을 도와줄 수 있도록 설계된 플랫폼이다. 도커를 지루한 설정 과정으 ㄹ대신해 주므로 코드를 작성하는 일에만 집중할 수 있다.
    ```
    
- Vercel, Netlify 활용한 배포
    - 서비스 공급업체가 배포 위한 사전 준비를 모두 해둠
    - `사전 준비` : 실행될 수 있는 컴퓨팅 리소스 확보, 사용하는 라이브러리에 따라 설치 방법 분리, 외부 네트워크로 이 앱을 개방 개방함
        - 개발자가 처음부터 해야 한다면 많은 작업이 필요함
        - 서버와 앱에 적절한 리소스를 확보, 운영체제 설치, Node.js 설치, 빌드
- 도커
    - 애플리케이션을 빠르게 배포할 수 있도록 ‘컨테이너’라는 단위로 패키징
    - ‘컨테이너’ 내부에서 앱이 실행될 수 있도록 도와줌
    - 독립된 환경에서 앱이 항상 일관되게 실행할 수 있도록 보장함
- 도커 용어
    - 이미지
        - 컨테이너를 만드는 데 사용되는 템플릿
        - Dockerfile이 필요하며, 이 파일 빌드 시 이미지 생성 가능
    - 컨테이너
        - 도커의 이미지를 실행한 상태
        - 독립된 공간이며, 이미지가 목표하는 운영체제, 파일 시스템, 각종 자원 및 네트워크 등이 할당되어 실행도 수 있는 독립된 공간이 생성됨
    - Dockerfile
        - 어떤 이미지 파일을 만들지 정의하는 파일
        - 빌드하면 이미지를 만들 수 있음
    - 태그
        - 이미지를 식별할 수 있는 레이블 값을 의미함
        - `이름: 태그명` 형태로 구성됨
    - 리포지터리
        - 이미지를 모아두는 저장소
        - 앞서 언급한 `이름` 에 다양한 태그로 지정된 이미지가 모여있는 저장소
    - 레지스트리
        - 리포지터리에 접근할 수 있게 해주는 서비스를 의미함
        - 대표적인 레지스트리: `도커 허브`
        - 레지스트리에는 다양한 리포지터리가 있으며, 이 리포지터리에서 사용자는 자신이 원하는 이미지를 내려받아 사용 가능
- 자주 쓰는 도커 cli 명령어
    - docker build
    - docker push
    - docker tag
    - docker inspect
    - docker run
    - docker rm

### create-react-app을 위한 Dockerfile 작성하기

- 프론트엔드 앱이 도커 이미지에서 해야 할 작업
    1. 운영체제 설정: 최소한의 운영체제 확보
    2. Node.js 설치
    3. npm ci : 프로젝트 빌드에 필요한 의존성 모듈 설치
    4. npm run build
    5. 실행 : cra는 정적 리소스를 서버에 올리는 것만으로도 충분
        
        ⇒ Dockerfile에 기재
        
- 앱이 실행되려면
    1. 빌드된 웹 앱을 NGINX가 서비스할 수 있도록 설정
    2. 이미지를 실행했을 때 해당 웹페이지에 접근할 수 있어야 함
    3. 웹페이지 접근에 필요한 빌드 파일만 남겨두고 용량 최소화
- Dockerfile에 명시된 내용을 바탕으로 이미지를 빌드하고, 컨테이너라고 하는 가상화 환경에서 웹 앱을 제공함
    - 이 이미지만 있으면 도커를 실행할 수 있는 모든 환경에서 동일한 앱을 실행 가능
- create-next-app을 위한 Dockerfile 작성하기
    - cra와 비슷하지만 빌드된 파일을 올리는 게 아니라 서버 실행이 필요함
    - `output: ‘standalone’`
        - Next.js에서 빌드를 위해 제공하는 기능
        - 이 옵션 추가 시 프로덕션에서 실행에 필요한 파일들만 모아서 바로 실행할 수 있는 준비를 대신해 줌

## 9.4.2 도커로 만든 이미지 배포하기

### 도커 이미지 업로드하기

- 도커 이미지도 도커 허브라는 공간에 업로드 가능
    - 가장 쉬운 방법: 도커 데스크톱을 이용
    - AWS의 Elastic Container Registry, Google Cloud Platform의 Container Registry 사용

### 도커 이미지 실행하기

- 사전 준비
    - GCP에 가입
    - 프로젝트 개설 후 CGP 제어 가능한 gcloud cli 설치
    - 프로젝트 지정
- Google Cloud Registry에 이미지 푸시
- Cloud Run에서 이미지 실행
    - Cloud Run : 푸시된 이미지를 클라우드 환경에서 손쉽게 실행할 수 있도록 도와주는 서비스
- 지속적 통합 설정
    - Cloud Run에서는 소스 저장소에서 Dockerfile을 다운로드해 빌드할 수 있는 옵션도 제공

## 9.4.3 정리

- 대부분의 기업에서는 앱을 토커라이즈해서 배포하고, 각 이미지를 관리하고 보관하면서 배포 관련 히스토리를 남겨두거나 빠르게 롤백하는 등의 용도로 도커를 사용함
- 프론트엔드 개발자라면 만든 앱을 도커라이즈하는 방법까지 숙지하고 있어야 함
- 추가로, k8s를 활용해 컨테이너 기반 앱을 좀 더 탄력적으로 배포가호 관리하며, 추가로 헬름 차트를 활용해 정적인 k8s의 템플릿을 상황에 맞게 관리할 수도 있음
